const dbPromise=idb.open('db',2,function(upgradeDb){switch(upgradeDb.oldVersion){case 0:upgradeDb.createObjectStore('restaurantsList',{keyPath:'id'});case 1:const reviewsStore=upgradeDb.createObjectStore('reviewsList',{keyPath:'id'});reviewsStore.createIndex('restaurant','restaurant_id')}});class DBHelper{static get DATABASE_URL(){const port=1337;return `http://localhost:${port}/`}
static fetchRestaurants(){return dbPromise.then(db=>{const tx=db.transaction('restaurantsList');const restaurantStore=tx.objectStore('restaurantsList');return restaurantStore.getAll()}).then(restaurants=>{if(restaurants.length!==0){return restaurants}
return fetch(DBHelper.DATABASE_URL+'restaurants').then(response=>response.json()).then(restaurants=>{return dbPromise.then(db=>{const tx=db.transaction('restaurantsList','readwrite');const restaurantStore=tx.objectStore('restaurantsList');restaurants.forEach(restaurant=>restaurantStore.put(restaurant));tx.complete;return restaurants})})})}
static fetchReviewsByRestaurantId(id){return fetch(DBHelper.DATABASE_URL+"reviews/?restaurant_id="+id,{method:"GET"}).then(resp=>resp.json()).then(reviews=>{dbPromise.then(db=>{if(!db)return;let tx=db.transaction('reviewsList','readwrite');const reviewsStore=tx.objectStore('reviewsList');if(Array.isArray(reviews)){reviews.forEach(function(review){reviewsStore.put(review)})}else{reviewsStore.put(reviews)}});console.log("reviews from servre",reviews);return(reviews)}).catch(error=>{return DBHelper.cacheReviewsFromDb(id)})}
static sendReviewsToServer(jsonData){var fetch_options={method:'POST',body:JSON.stringify(jsonData),headers:new Headers({'Content-Type':'application/json'})}
fetch("http://localhost:1337/reviews",fetch_options).then(function(response){return response.json()}).then(function(data){console.log("Saved reviews successfully");DBHelper.saveReviewsToDatabase(data)}).catch(function(error){return console.log('error:',error)})}
static sendReviewsWhenOnline(data){DBHelper.saveReviewsTolocalStorage(data);console.log("saving data to local storage",data);window.addEventListener('online',(event)=>{console.log("online again");var offLineData=DBHelper.getReviewsFromlocalStorage();console.log(offLineData);if(offLineData!==null){offLineData.forEach(reviewObj=>{DBHelper.sendReviewsToServer(reviewObj.data)})}
console.log('LocalStorage data sent to server');localStorage.removeItem('reviews');console.log("localStorage + ${offLineData.object_type}   removed")})}
static saveReviewsToDatabase(reviews){dbPromise.then(function(db){if(!db)return;var tx=db.transaction("reviewsList","readwrite");var store=tx.objectStore("reviewsList");if(reviews!==undefined&&Array.isArray(reviews)){reviews.forEach(function(res){store.put(res)})}else{store.put(reviews)}
return tx.complete})}
static saveReviewsTolocalStorage(offlineReviewsList){var existing=localStorage.getItem('reviews');existing=existing?JSON.parse(existing):[];existing.push(offlineReviewsList);window.localStorage.setItem("reviews",JSON.stringify(existing))}
static getReviewsFromlocalStorage(){return JSON.parse(window.localStorage.getItem("reviews"))}
static fetchRestaurantById(id){return DBHelper.fetchRestaurants().then(restaurants=>restaurants.find(r=>r.id===id))}
static fetchRestaurantByCuisine(cuisine){return DBHelper.fetchRestaurants().then(restaurants=>restaurants.filter(r=>r.cuisine_type==cuisine))}
static fetchRestaurantByNeighborhood(neighborhood){return DBHelper.fetchRestaurants().then(restaurants=>restaurants.filter(r=>r.neighborhood==neighborhood))}
static fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood){return DBHelper.fetchRestaurants().then(restaurants=>{let results=restaurants;if(cuisine!=='all'){results=results.filter(r=>r.cuisine_type==cuisine)}
if(neighborhood!=='all'){results=results.filter(r=>r.neighborhood==neighborhood)}
return results})}
static fetchNeighborhoods(){return DBHelper.fetchRestaurants().then(restaurants=>{const neighborhoods=restaurants.map((v,i)=>restaurants[i].neighborhood)
const uniqueNeighborhoods=neighborhoods.filter((v,i)=>neighborhoods.indexOf(v)==i)
return uniqueNeighborhoods})}
static fetchCuisines(callback){return DBHelper.fetchRestaurants().then(restaurants=>{const cuisines=restaurants.map((v,i)=>restaurants[i].cuisine_type)
const uniqueCuisines=cuisines.filter((v,i)=>cuisines.indexOf(v)==i)
return uniqueCuisines})}
static updateFavouriteStatus(restaurantId,isFavourite){console.log('changing favorite status to: ',isFavourite);fetch(`http://localhost:1337/restaurants/${restaurantId}/?is_favorite=${isFavourite}`,{method:'PUT'}).then(()=>{dbPromise.then(db=>{const tx=db.transaction('restaurantsList','readwrite');const restaurantsStore=tx.objectStore('restaurantsList');restaurantsStore.get(restaurantId).then(restaurant=>{restaurant.is_favorite=isFavourite;restaurantsStore.put(restaurant)})})})}
static cacheReviewsFromDb(id){var reviews=dbPromise.then(function(db){var tx=db.transaction("reviewsList","readonly");var store=tx.objectStore("reviewsList");return store.getAll(id)});return reviews}
static urlForRestaurant(restaurant){return(`./restaurant.html?id=${restaurant.id}`)}
static imageUrlForRestaurant(restaurant){return(`/img/${restaurant.photograph}.webp`)}
static mapMarkerForRestaurant(restaurant){const marker=new L.marker([restaurant.latlng.lat,restaurant.latlng.lng],{title:restaurant.name,alt:restaurant.name,url:DBHelper.urlForRestaurant(restaurant)});marker.addTo(newMap);return marker}}